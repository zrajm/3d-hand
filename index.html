<!DOCTYPE html><!--*-js-indent-level:2;css-indent-offset:2-*-->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hand Shapes</title>
<style>
  body { margin: 0; }
  canvas { display: block; }
</style>
<body>
<script type="module">
  import * as THREE from './js/three.min.js'
  import { OrbitControls } from './js/three-orbit-controls.min.js'
  import { GUI } from './js/dat-gui.min.js'

  // Usage: createMesh(geometryName, args, [{ x, y, z, a, b, c, material }])
  function createMesh(name, ...args) {
    const xtra = typeof args.at(-1) === 'object' ? args.pop() : {}
    const threeName = name[0].toUpperCase() + name.slice(1) + 'Geometry'
    const geometry = new THREE[threeName](...args)
    return modifyMesh(new THREE.Mesh(geometry), xtra)
  }

  // Usage: createMesh(geometry, [{ x, y, z, a, b, c, material }])
  const defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff })
  function modifyMesh(geometry, {
    x = 0, y = 0, z = 0,            // position
    a = 0, b = 0, c = 0,            // rotation
    material = defaultMaterial,
  }) {
    geometry.rotation.set(a, b, c)
    geometry.position.set(x, y, z)
    if (Object.hasOwn(geometry, 'material')) {
      geometry.material = material
    }
    return geometry
  }

  // Set up the scene, camera, and renderer
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
  const renderer = new THREE.WebGLRenderer({ antialias: true })
  renderer.setSize(window.innerWidth, window.innerHeight)
  document.body.appendChild(renderer.domElement)

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, Math.PI * .1)
  scene.add(ambientLight)

  const directionalLight = new THREE.DirectionalLight(0xffffff, Math.PI)
  directionalLight.position.set(5, 5, 5).normalize()
  scene.add(directionalLight)

  // Hand base
  const handGeometry = new THREE.BoxGeometry(1.6, 1.6, 0.4)
  const handMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff })
  handMaterial.wireframe = true
  const hand = new THREE.Mesh(handGeometry, handMaterial)
  scene.add(hand)
  hand.position.set(0, -1, 0)

  // Finger segments
  const fingerLength = 0.75
  const fingerWidth  = 0.2

  function createFingerSegment(width, length, xtra = {}) {
    return modifyMesh(new THREE.Group(), xtra)
      .add(createMesh('sphere', width))    // base
      .add(createMesh('cylinder', width, width, length, { y: length / 2 }))
      .add(createMesh('sphere', width, { y: length }))   // tip
  }

  function createFinger(x, y, z, width, length, [a = 0, b = 0, c = 0] = []) {
    // Outer segment (fingertip)
    const outerSegment = createFingerSegment(width, length * .5, { y: length * .7 })

    // Middle segment
    const middleSegment = createFingerSegment(width, length * .7, { y: length })
      .add(outerSegment)

    // Inner segment (closest to palm)
    const innerSegment = createFingerSegment(width, length)
      .add(middleSegment)

    // Whole finger
    const finger = modifyMesh(new THREE.Group(), { x, y, z, a, b, c })
      .add(innerSegment)

    hand.add(finger)
    return [innerSegment, middleSegment, outerSegment, finger]
  }

  const fingers = [
    ["Thumb",         ...createFinger( .6,  -.8,  0,  fingerWidth,       fingerLength, [Math.PI * .5, Math.PI, -.25])],
    ["Index Finger",  ...createFinger( .6, .85, -.05, fingerWidth * .95, fingerLength * .88)],
    ["Middle Finger", ...createFinger( .2, .9,  -.1,  fingerWidth,       fingerLength)],
    ["Ring Finger",   ...createFinger(-.2, .85, -.05, fingerWidth * .95, fingerLength * .88)],
    ["Little Finger", ...createFinger(-.6, .8,  0,    fingerWidth * .8,  fingerLength * .65)],
  ]

  // GUI controls
  const gui = new GUI()
  for (const finger of fingers) {
    const folder = gui.addFolder(finger[0])
    folder.add(finger[1].rotation, 'x', 0, Math.PI / 2.1).name('Inner joint')
    folder.add(finger[2].rotation, 'x', 0, Math.PI / 1.7).name('Middle joint')
    folder.add(finger[3].rotation, 'x', 0, Math.PI / 2.4).name('Outer joint')
    folder.add(finger[4].rotation, 'z', Math.PI * -.1, Math.PI * .1).name('Spread')
    folder.open()
  }

  // Camera position
  camera.position.set(2, 1, 4)
  const controls = new OrbitControls(camera, renderer.domElement)
  controls.enableDamping = true                // enable inertia
  controls.dampingFactor = 0.05
  controls.screenSpacePanning = false
  controls.maxPolarAngle = Math.PI

  // Animation loop
  function animate() {
    requestAnimationFrame(animate)
    controls.update()
    renderer.render(scene, camera)
  }
  animate()

  // Resize handling
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  })
</script>
</body>
