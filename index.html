<!DOCTYPE html><!--*-js-indent-level:2;css-indent-offset:2-*-->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hand Shapes</title>
<style>
  body { margin: 0; }
  canvas { display: block; }
</style>
<body>
<script type="importmap">{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.166.0/build/three.module.min.js",
    "three/addons/controls/": "https://cdn.jsdelivr.net/npm/three@0.166.0/examples/jsm/controls/",
    "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.min.js"
  }
}</script>
<script type="module">

  import * as THREE from 'three'
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
  import { GUI } from 'dat.gui'

  // Set up the scene, camera, and renderer
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
  const renderer = new THREE.WebGLRenderer({ antialias: true })
  renderer.setSize(window.innerWidth, window.innerHeight)
  document.body.appendChild(renderer.domElement)

  // Lighting
  const ambientLight = new THREE.AmbientLight(0x404040)
  scene.add(ambientLight)

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1)
  directionalLight.position.set(5, 5, 5).normalize()
  scene.add(directionalLight)

  // Hand base
  const handGeometry = new THREE.BoxGeometry(1.6, 1.6, 0.4)
  const handMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 })
  handMaterial.wireframe = true
  const hand = new THREE.Mesh(handGeometry, handMaterial)
  scene.add(hand)
  hand.position.set(0, -1, 0)

  // Finger segments
  const fingerLength = 0.75
  const fingerWidth  = 0.2
  const segmentMaterial = new THREE.MeshPhongMaterial({ color: 0xAAAAAA })

  function createThreeGeometry(threeGeometry, threeMaterial, x = 0, y = 0, z = 0) {
    const geometry = new THREE.Mesh(threeGeometry, threeMaterial)
    geometry.position.set(x, y, z)
    return geometry
  }

  function createFingerSegment(width, length, material = segmentMaterial) {
    const rez = 32
    return new THREE.Group()
      .add(createThreeGeometry(                // bottom sphere
        new THREE.SphereGeometry(width, rez, rez),
        material,
      ))
      .add(createThreeGeometry(                // middle cylinder bit
        new THREE.CylinderGeometry(width, width, length, rez),
        material,
        0, length / 2, 0,
      ))
      .add(createThreeGeometry(                // top sphere
        new THREE.SphereGeometry(width, rez, rez),
        material,
        0, length, 0,
      ))
  }

  function createFinger(x, y, z, width = fingerWidth, length = fingerLength) {
    // Outer segment (fingertip)
    const segment3 = createFingerSegment(width, length * .5)
    segment3.position.set(0, length * .7, 0)

    // Middle segment
    const segment2 = createFingerSegment(width, length * .7)
    segment2.add(segment3)
    segment2.position.set(0, length, 0)

    // Inner segment (closest to palm)
    const segment1 = createFingerSegment(width, length)
    segment1.add(segment2)

    // Whole finger
    const finger = new THREE.Group()
    finger.add(segment1)
    finger.position.set(x, y, z)

    hand.add(finger)
    return [segment1, segment2, segment3]
  }

  // Create fingers
  const fingers = [
    ["Thumb",         ...createFinger(1,  -.8,  0,    fingerWidth,       fingerLength)],
    ["Index Finger",  ...createFinger( .6, .85, -.05, fingerWidth * .95, fingerLength * .88)],
    ["Middle Finger", ...createFinger( .2, .9,  -.1,  fingerWidth,       fingerLength)],
    ["Ring Finger",   ...createFinger(-.2, .85, -.05, fingerWidth * .95, fingerLength * .88)],
    ["Little Finger", ...createFinger(-.6, .8,  0,    fingerWidth * .8,  fingerLength * .65)],
  ]

  // GUI controls
  const gui = new GUI()
  fingers.forEach((finger, index) => {
    const folder = gui.addFolder(finger[0])
    folder.add(finger[1].rotation, 'x', 0, Math.PI / 2.1).name('Inner joint')
    folder.add(finger[2].rotation, 'x', 0, Math.PI / 1.7).name('Middle joint')
    folder.add(finger[3].rotation, 'x', 0, Math.PI / 2.4).name('Outer joint')
    folder.open()
  })

  // Camera position
  camera.position.set(2, 1, 4)
  const controls = new OrbitControls(camera, renderer.domElement)
  controls.enableDamping = true                // enable inertia
  controls.dampingFactor = 0.05
  controls.screenSpacePanning = false
  controls.maxPolarAngle = Math.PI / 2

  // Animation loop
  function animate() {
    requestAnimationFrame(animate)
    controls.update()
    renderer.render(scene, camera)
  }

  animate()

  // Resize handling
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  })
</script>
</body>
